package data

import (
	"context"
	"errors"
	"fmt"
	"time"

	"github.com/google/uuid"
	"github.com/weaviate/weaviate-go-client/v6/internal"
	"github.com/weaviate/weaviate-go-client/v6/internal/api"
	"github.com/weaviate/weaviate-go-client/v6/internal/dev"
	"github.com/weaviate/weaviate-go-client/v6/types"
)

func NewClient(t internal.Transport, rd api.RequestDefaults) *Client {
	dev.AssertNotNil(t, "nil transport")

	return &Client{
		transport: t,
		defaults:  rd,
	}
}

type Client struct {
	transport internal.Transport
	defaults  api.RequestDefaults
}

type (
	Reference  api.ObjectReference
	References map[string][]Reference
)

type Object struct {
	UUID          *uuid.UUID
	CreatedAt     time.Time
	LastUpdatedAt time.Time
	Properties    map[string]any
	References    References
	Vectors       []types.Vector
}

// Insert new object into a collection.
// To create an object without data or vectors and a UUID
// generated by the server, pass nil as the second parameter.
func (c *Client) Insert(ctx context.Context, o *Object) (*types.Object[map[string]any], error) {
	o = internal.Optional(o)
	req := &api.InsertObjectRequest{
		RequestDefaults: c.defaults,
		UUID:            o.UUID,
		Properties:      o.Properties,
		Vectors:         newAPIVectors(o.Vectors),
		References:      newAPIReferences(o.References),
	}

	var resp api.InsertObjectResponse
	if err := c.transport.Do(ctx, req, &resp); err != nil {
		return nil, fmt.Errorf("insert object: %w", err)
	}

	return &types.Object[map[string]any]{
		UUID:          resp.UUID,
		CreatedAt:     resp.CreatedAt,
		LastUpdatedAt: resp.LastUpdatedAt,
		Properties:    resp.Properties,
		Vectors:       newVectors(resp.Vectors),
		References:    newReferences(resp.References),
	}, nil
}

func (c *Client) Replace(ctx context.Context, o Object) (*types.Object[map[string]any], error) {
	if o.UUID == nil {
		return nil, errors.New("uuid is nil")
	}

	req := &api.ReplaceObjectRequest{
		RequestDefaults: c.defaults,
		UUID:            o.UUID,
		Properties:      o.Properties,
		Vectors:         newAPIVectors(o.Vectors),
		References:      newAPIReferences(o.References),
	}

	var resp api.ReplaceObjectResponse
	if err := c.transport.Do(ctx, req, &resp); err != nil {
		return nil, fmt.Errorf("replace object: %w", err)
	}

	return &types.Object[map[string]any]{
		UUID:          resp.UUID,
		CreatedAt:     resp.CreatedAt,
		LastUpdatedAt: resp.LastUpdatedAt,
		Properties:    resp.Properties,
		Vectors:       newVectors(resp.Vectors),
		References:    newReferences(resp.References),
	}, nil
}

func (c *Client) Delete(ctx context.Context, id uuid.UUID) error {
	req := api.DeleteObjectRequest{
		RequestDefaults: c.defaults,
		UUID:            id,
	}
	if err := c.transport.Do(ctx, &req, nil); err != nil {
		return fmt.Errorf("delete object: %w", err)
	}
	return nil
}

func newVectors(vectors api.Vectors) types.Vectors {
	if len(vectors) == 0 {
		return nil
	}

	vs := make(types.Vectors, len(vectors))
	for _, v := range vectors {
		vs[v.Name] = types.Vector(v)
	}
	return vs
}

func newAPIVectors(vectors []types.Vector) []api.Vector {
	if len(vectors) == 0 {
		return nil
	}

	vs := make([]api.Vector, len(vectors))
	for i, v := range vectors {
		vs[i] = api.Vector(v)
	}
	return vs
}

func newReferences(rs api.ObjectReferences) References {
	if len(rs) == 0 {
		return nil
	}

	out := make(References, len(rs))
	for name, r := range rs {
		refs := make([]Reference, len(r))
		for i := range r {
			refs[i] = Reference(r[i])
		}
		out[name] = refs
	}
	return out
}

func newAPIReferences(rs References) api.ObjectReferences {
	if len(rs) == 0 {
		return nil
	}

	out := make(api.ObjectReferences, len(rs))
	for name, r := range rs {
		refs := make([]api.ObjectReference, len(r))
		for i := range r {
			refs[i] = api.ObjectReference(r[i])
		}
		out[name] = refs
	}
	return out
}
